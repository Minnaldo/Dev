# 알고리즘 2

## 정렬
|알고리즘|평균수행시간|최악수행시간|알고리즘 기법|비고|
|:---:|:---:|:---:|:---:|:---:|
|버블 정렬|O(n^2)|O(n^2)|비교와 교환|코딩이 가장 쉽다|
|카운팅 정렬|O(n+k)|O(n+k)|비교환 방식|n이 비교적 작을 때만 가능하다|
|선택 정렬|O(n^2)|O(n^2)|비교와 교환|교환의 회수가 버블, 삽입정렬보다 작다|
|퀵 정렬|O(n log n)|O(n^2)|분할 정복|최악의 경우 O(n^2) 이지만, 평균적으로는 가장 빠르다|
|삽입 정렬|O(n^2)|O(n^2)|비교와 교환|n의 개수가 작을 때 효과적이다|
|병합 정렬|O(n log n)|O(n log n)|분할 정복|연결리스트의 경우 가장 효율적인 방식|


#### 버블 정렬
버블 정렬은 1회전을 수행하면, 가장 큰 값(또는 가장 작은 값)이 맨 뒤로 가게 된다.<br>
그러므로, 1회 수행시마다 안쪽 반복문의 **반복 횟수를 1씩 줄여**나가면 효율적이게 된다.

#### 카운팅 정렬
각 숫자별로 빈도수를 세고, 나보다 작은 수의 갯수 + 1 만큼의 자리가 자리
이를 위해, 0부터 N까지의 인덱스를 갖는 배열을 만들고, 각 인덱스에 해당 숫자의 빈도를 기록

- 한계 : 제약사항이 많다
    - 정수 or 정수형으로 나타낼 수 있는 데이터에만 정렬 가능
    - 가장 큰 정수를 알아야 한다
    - 필요없는 공간을 차지할 수 있다 ( ex. 1, 2, 3, 1000 일 때, 배열은 1000개가 만들어져야 한다 )

## 부분집합 구하기
부분집합의 갯수는 2^n 개 이다

- 부분집합을 구하는 방법
    1. 비트마스크 활용
        - 비트연산자는 비트단위로 연산을 하게 됨. 즉, int형 정수 (4byte : 32 bit)의 32bit 모두에 대하여 각각 자리에 맞게 bit연산을 수행함
        - 그러므로 따로 변한해주지 않아도 bit연산을 하므로 신경쓸게 줄어든다

    ```java
        // 원소가 3개인 집합의 부분집합 구하기
        // bit operator 이용
        // 8은 1<<3 으로 나타낼수 있다.
        String[] fruit
        for(int i = 0; i<8; i++){
            if((1&i) != 0)  // 첫번째 자리 체크
                System.out.println(fruit[i]);
            if((2&i) != 0)  // 두번째 자리 체크
                System.out.println(fruit[i]);
            if((3&i) != 0)  // 세번째 자리 체크
                System.out.println(fruit[i]);
        }

        // 위 코드를 보기 쉽게 변형한 것
        for (int i = 0; i < (1 << 3); i++) {
            for (int j = 0; j < 3; j++) {
                if (((1 << j) & i) != 0) {
                    System.out.print(fruits[j] + " ");
                }
            }
            System.out.println();
        }

    ```


    2. 재귀함수 활용