# Algorithm Summary Week3

## 문자열(String)

#### 인코딩이란?
- Encode + ing : 부호화 하다, 코드화 하다 라는 뜻을 가진다.
- 달리 말하면, 어떠한 것을 협의된 약속에 맞게 변환시키는 과정을 뜻한다
- 반의어 : Decoding(디코딩; 코드화 한 것을 원래의 모습으로 변환시키는 과정)

> 오늘날 대부분의 컴퓨터는 문자를 읽고 쓰는데 ASCII형식을 사용한다.

### 유니코드
인터넷이 발달해 국가간 통신을 할 때, 파편화된 코드체계로 인해 해석에 문제가 생기기 시작하였다.<br>

이러한 문제를 해결하기 위해 다국어 처리를 위한 표준을 만들었고, 이를 `유니코드`라 한다.

## 스택 (Stack)
LIFO(Last In First Out)특성을 가지는 자료구조

정적으로 구현할 때는 배열을 이용하고, 동적으로 구현할때는 리스트 등을 이용할 수 있다.

자바에서는 기본적으로 제공되는 `stack`이 있다

```java
public class Stack<E> extends Vector<E>
```
위 코드에서 알 수 있듯이, 기본 제공되는 스택은 제너릭으로 구현되어 있으며, Vector<E> 클래스를 상속받는다.

|Member Method|Function|
|:--:|:--:|
|push(E item)|item을 스택에 추가|
|pop()|top 값을 반환, 후 해당 값을 제거|
|peek()|top의 값을 리턴한다. top의 값의 변화가 없다|
|empty()|스택이 비었는지 여부를 리턴|
|serach(Obejct o)|data의 보관한 순번 반환(1부터 시작)|


### Function Call
- 프로그램에서의 함수 호출과 복귀에 따른 수행순서를 관리
    - 가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀하는 후입선출 구조이므로, 후입선출 구조의 스택을 이용하여 수행순서 관리
    - 함수 호출이 발생하면 호출한 함수 수행에 필요한 지역변수, 매개변수 및 수행 후 복귀할 주소 등의 정보를 스택 프레임(Stack Frame)에 저장하여 시스템 스택에 삽입
    - 함수 실행이 끝나면 시스템 스택의 top원소(스택 프레임)를 삭제(pop)하면서 프레임에 저장되어 있던 복귀주소를 확인하고 복귀
    - 함수 호출과 복귀에 따라 이 과정을 반복하여 전체 프로그램 수행이 종료되면 시스템 스택은 공백 스택이 된다.

![Function Call Structure](./img/FunctionCall.png)

### 재귀 호출 (Recursive Call)
- 자기 자신을 호출하여 순환 수행되는 것
- 함수에서 실행해야 하는 작업의 특성에 따라 일반적인 호출방식보다 재귀호출 방식을 사용하여 함수를 만들면 프로그램 크기를 줄이고 간단하게 작성

```
재귀호출의 예) factorial
n! = n x (n-1)!
    (n-1)! = (n-1) x (n-2)!
    (n-2)! = (n-2) x (n-3)!
...
    2! = 2 x 1
    1! = 1
```
- 마지막에 구한 하위 값을 이용하여 상위값을 구하는 작업을 반복

### Memoization
- 메모이제이션(Memoization)은 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술이다. `동적 계획법의 핵심이 되는 기술`이다

### DP(Dynamic Programming)
- 동적계획(Dynamic Programming) 알고리즘은 그리디 알고리즘과 같이 `최적화 문제`를 해결하는 알고리즘이다.

- 동적 계획 알고리즘은 먼저 크기가 작은 부분 문제들을 모두 해결한 후에 그 해들을 이용하여 보다 큰 크기의 부분문제들을 해결하여, 최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘이다.

## DFS (깊이 우선 탐색)
- 비선형구조인 그래프 구조는 그래프로 표현된 `모든 자료를 빠짐없이 검색`하는 것이 중요
- 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가, 더 이상 갈 곳이 없게 되면, 가장 마지막에 만났던 갈림길 간선이 있는 `정점으로 되돌아와서` 다른 방향의 정점으로 탐색을 계속 반복하여 결국 `모든 정점을 방문`하는 순회 방법
- 가장 마지막에 마났떤 갈림길의 정점으로 되돌아가서 다시 깊이 우선 탐색을 반복해야 하므로 후입선출(LIFO) 구조의 `스택` 사용

### DFS 알고리즘
1.  시작 정점 v를 결정하여 방문한다.
1.  정점 v에 인접한 정점 중에서
    1. 방문하지 않은 정점 w가 있으면, 정점 v를 스택에 push하고 정점 w를 방문, 그리고 w를 v로하여 다시 **2.** 를 반복
    1. 방문하지 않은 정점이 없으면, 탐색의 방향을 바꾸기 위해 스택을 pop하여 받은 가장 마지막 방문 정점을 v로 하여 다시 **2.** 로 반복
1. 스택이 공백이 될때까지 **2.** 를 반복한다


```java
DFS(v)
    for (i = 0; i<n; i++){
        visited[i] = false; // 방문 배열 초기화
    }

    Stack<Integer> s = new Stack<>();   // 스택 생성
    visited[v] = true;  // v 방문 체크
    v 방문;

    while(!s.isEmpty()){
        // 인접 정점 방문 확인
        if(visited[v의 인접정점 w] == false){
            // 인접 정점을 방문하지 않았을 때
            s.push(v);  // 현재 정점을 스택에 push
            visited[w]; // 인접정점을 방문체크
            w 방문;
            v <- w; // w를 v로해서 dfs 실행
        }
        else{
            // 인접 정점이 모두 방문했을 때
            s.pop();    // 스택에 pop해 이전으로 돌아간다
        }
    }
end DFS()
```


#### 후위식 계산기
후위식?
    - 연산자를 피연산자 위에 표기하는 방법<br>
    예) AB+
1. 중위식을 후위식으로 변경(스택 이용)
1. 후위식을 스택을 이용하여 계산

후위 계산기
- 연산자를 만나면 스택에서 피연산자 2개를 pop해서 연산 후, 다시 스택에 저장(push)

후위식 만들기 ( 중위식 -> 후위식)
- 숫자는 그냥 출력 ( 배열에 넣는다 )
- 연산자면
    - 덧셈일 경우 : 스택에 있는 연산자를 모두 꺼내어 출력하고 덧셈을 담는다.
    - 곱셈일 경우 스택의 맨 위에 덧셈이 있으면 스택에 담고, 곱셈이 있으면 꺼내서 출력하고 스택에 담는다.


연산자 우선순위

|연산자|우선순위|
|:--:|:--:|
|*, /|1|
|+, -|2|
|(|3|
|)|4|

우선순위가 동급이거나 빌때까지 스택에서 pop을 해 배열에 저장
