# 병합 정렬과 퀵 정렬

## 병합 정렬
1. 분할 정복 방식의 정렬 방법
1. 배열을 최대 2의 구간을 가질 때까지 분할 한다 ( 재귀 함수를 이용한다 )
1. 분할이 다 끝나면, 분할된 부분을 비교/정렬 하며 합친다
    - 왼쪽 부분배열의 원소와 오른쪽 부분 배열의 원소를 비교하며 임시 배열에 저장을 하는 방식을 이용한다
    - 병합 시 `while()`문을 사용하는 것이 적절하며, 왼쪽 배열을 순회할 인덱스, 오른쪽 배열을 순회할 인덱스 그리고 임시 배열을 순회할 인덱스를 이용하여 순회한다.
    ```java
        // 분할된 배열을 합치는 구문
        while(start <= mid && right <= end) {
            if(arr[start] <= arr[right])
                tmp[tmpidx++]=arr[start++];
            else
                tmp[tmpidx++]=arr[right++];
        }

        // 분할 후 병합된 배열을 원래 배열에 적용하는 부분
        // end가 마지막 인덱스이므로 포함해주어야 한다.
        for(int i = start; i <= end; i++)
            arr[i] = tmp[i];
    ```

#### 병합정렬 알고리즘의 특징
- 장점
    - 안정적인 정렬 방법
        - 데이터 분포에 영향을 덜 받는다. 즉, 입력 데이터가 무엇이든 간에 정렬되는 시간은 동일하다. (O(nlogn)으로 동일)
    - 만약 레코드를 연결 리스트(Linked List)로 구성하면, 링크 인덱스만 변경되므로 데이터의 이동은 무시할 수 있을 정도로 작아진다.
        - 제자리 정렬(in-place sorting)로 구현할 수 있다.
    - 따라서 크기가 큰 레코드를 정렬할 경우에 연결 리스트를 사용한다면, 합병 정렬은 퀵 정렬을 포함한 다른 어떤 정렬 방법보다 효율적이다.

- 단점
    - 만약 레코드를 배열(Array)로 구성하면, 임시 배열이 필요하다.
        - 제자리 정렬(in-place sorting)이 아니다.
    - 레코드들의 크기가 큰 경우에는 이동 횟수가 많으므로 매우 큰 시간적 낭비를 초래한다.

1. 합칠 때는 비교를 하며 합치고, 나머지 부분을 차례로 넣어준다
```java
        // 남아있는 분할 배열을 넣어주는 구문
        if(start < mid)
            for(int i = start; i<=mid; i++)
                tmp[tmpidx++] = arr[i];
        else
            for(int i = right; i<= end; i++)
                tmp[tmpidx++] = arr[i];
```
1. 나머지 부분은 왼쪽 부분배열을 순서대로 넣은 후, 오른쪽 부분 배열을 순서대로 넣어준다
1. 위의 과정을 반복하면 정렬이 완료된다



## 퀵 정렬
- 분할 정복 방식의 정렬 방법
- 피벗을 정한 후, 피벗을 기준으로 분할하며 정복해 나가는 방식의 정렬 방법
- 피벗을 정한다
    - 대체적으로 왼쪽 또는 오른쪽 끝단을 선택하나, 랜덤으로 선택해도 무방하다

- 퀵 졍렬은 **불안정 정렬**에 속하며, 다른 원소와의 비교만으로 정렬을 수행하는 **비교 정렬**에 속한다.
- 분할 정복 알고리즘의 하나로, 평균적으로 **매우 빠른 수행속도**를 자랑하는 정렬 방법
    - 합병 정렬(merge sort)과 달리 퀵 정렬은 리스트를 **비균등하게** 분할한다.
- 분할 정복(divide and conquer) 방법
    - 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략
    - 분할 정복 방법은 대개 순한 호출을 이용하여 구현한다.
- 과정 설명
    1. 리스트 안에 있는 한 요소를 선택한다. 이를 **피벗(pivot)** 이라고 한다.
    1. 피벗을 기준으로 피벗보다 작은 요소들은 모두 피벗의 왼쪽으로 옮겨지고 피벗보다 큰 요소들은 모두 피벗의 오른쪽으로 옮겨진다. (피벗을 중심으로 왼쪽: 피벗보다 작은 요소들, 오른쪽 : 피벗보다 큰 요소들)
    1. 피벗을 제외한 왼쪽 리스트와 오른쪽 리스트를 다시 정렬한다.
        - 분할된 부분 리스트에 대하여 **순환 호출**을 이용하여 정렬을 반복한다.
        - 부분 리스트에서도 다시 피벗을 정하고 피벗을 기준으로 2개의 부분 리스트로 나누는 과정을 반복한다.
    1. 부분 리스트들이 더 이상 분할이 불가능할 때까지 반복한다.
        - 리스트의 크기가 0이나 1이 될 때까지 반복한다.

#### 퀵 정렬(Quick sort) 알고리즘의 특징
- 장점
    1. 속도가 빠르다
        - 시간 복잡도가 O(nlogn)를 가지는 다른 정렬 알고리즘과 비교했을 때도 가장 빠르다.
    1. 추가 메모리 공간을 필요로 하지 않는다.
        - 퀵 정렬은 O(log n)만큼의 메모리를 필요로 한다.
- 단점
    1. 정렬된 리스트에 대해서는 퀵 정렬의 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다.
- 퀵 정렬의 부균형 분할을 방지하기 위하여 피벗을 선택할 때 더욱 리스트를 균등하게 분할할 수 있는 데이터를 선택한다.
    - ex) 리스트 내의 몇 개의 데이터 중에서 크기순으로 중간 값(medium)을 피벗으로 선택한다.


